# 一、定义scheme

## Tables


FlatBuffers 中定义对象的主要方式，由名称和字段列表组成。每个字段都有一个名称、一个类型和一个可选的默认值。
如果架构中未指定默认值，则标量类型的默认值将为 0 ，其他类型的默认值将为 null 。

- 限制
1. 只能在表定义的末尾在架构中添加新字段，如果您希望灵活地在架构中使用任何顺序的字段，您可以手动分配 id。
2. 无法从架构中删除不再使用的字段，但您可以简单地停止将它们写入数据中以获得几乎相同的效果。此外，您可以将它们标记为 deprecated
3. 如果您可以更改代码，则可以更改字段名称和表名称，直到您也在那里重命名它们为止。

## Structs
与表类似，只是现在没有任何字段是可选的（因此也没有默认值），并且不能添加或弃用字段。结构体只能包含标量或其他结构体。将此用于您非常确定不会进行任何更改的简单对象。
结构比表使用更少的内存，并且访问速度更快


## Types
- 内置类型
    - 8 bit: byte (int8), ubyte (uint8), bool
    - 16 bit: short (int16), ushort (uint16)
    - 32 bit: int (int32), uint (uint32), float (float32)
    - 64 bit: long (int64), ulong (uint64), double (float64)
其中括号中的类型名称是别名

- 内置非标量类型：
- `[type]`
- `string` 只能保存 UTF-8 或 7 位 ASCII。对于其他文本编码或一般二进制数据，请使用向量 `[byte]`

一旦使用字段，您就无法更改它们的类型，但相同大小的数据除外

## Array
数组是固定长度元素集合的便捷简写。
- 比如说：
```
struct Vec3 {
    x:float;
    y:float;
    z:float;
}
```
- 可以替换为：
```
struct Vec3 {
    v:[float:3];
}
```

## 默认值、可选值和必需值

## 枚举
定义一系列命名常量，每个常量都有一个给定值，或者比前一个值增加 1。默认的第一个值为 0 。

通常，枚举值只能被添加，不能被删除（枚举不会被弃用）。这需要代码通过处理未知的枚举值来处理自身的前向兼容性。


## 工会(Unions)

联合与枚举共享许多属性，但您使用表名称而不是常量的新名称。然后，您可以声明一个联合字段，它可以保存对任何这些类型的引用，此外还会生成一个后缀为 _type 的字段，该字段保存相应的枚举值，让您知道要转换哪种类型到运行时。


## namespace
仅C++和java代码生成的时候有这个概念。

## 其它
- Root Type
这声明了您认为是序列化数据的根表。这对于解析不包含对象类型信息的 JSON 数据尤其重要。


# 二、在C++中使用

## 序列化

FlatBuffers 的核心是内存效率，这就是为什么它的基本 API 是围绕使用尽可能少的内存而编写的。这确实使 API 变得更加笨拙（需要对所有数据进行预序构建，并使突变变得更加困难）。
```c++

// Autogenerated class from table Monster.
MonsterT monsterobj;

// Deserialize from buffer into object.
GetMonster(flatbuffer)->UnPackTo(&monsterobj);

// Update object directly like a C++ class instance.
cout << monsterobj.name;  // This is now a std::string!
monsterobj.name = "Bob";  // Change the name.

// Serialize into new flatbuffer.
FlatBufferBuilder fbb;
fbb.Finish(Monster::Pack(fbb, &monsterobj));
```

## 反序列化
```c++
#include "flatbuffers/flatbuffers.h"
#include "monster_test_generate.h"
#include <iostream> // C++ header file for printing
#include <fstream> // C++ header file for file access


std::ifstream infile;
infile.open("monsterdata_test.mon", std::ios::binary | std::ios::in);
infile.seekg(0,std::ios::end);
int length = infile.tellg();
infile.seekg(0,std::ios::beg);
char *data = new char[length];
infile.read(data, length);
infile.close();

auto monster = GetMonster(data);

```


# 三、在Python中使用

# 四、 flatbuffer白皮书

FlatBuffer 是一个二进制缓冲区，包含使用偏移量组织的嵌套对象（结构、表、向量等），以便可以像任何基于指针的数据结构一样就地遍历数据。然而，与大多数内存数据结构不同，它使用严格的对齐和字节顺序规则（总是很小）来确保这些缓冲区是跨平台的。此外，对于表对象，FlatBuffers 提供向前/向后兼容性和字段的一般可选性，以支持大多数形式的格式演变。

您可以在模式中定义对象类型，然后可以将其编译为 C++ 或 Java，以实现低至零开销的读写。 （可选）JSON 数据可以动态解析到缓冲区中。
- Table表格

表是 FlatBuffers 的基石，因为格式演变对于大多数序列化应用程序至关重要。通常，处理格式更改可以在大多数序列化解决方案的解析过程中透明地完成。但是 FlatBuffer 在被访问之前不会被解析。

表通过使用额外的间接访问字段（通过 vtable）来解决这个问题。每个表都带有一个 vtable（可以在具有相同布局的多个表之间共享），并且包含存储这种特定类型的 vtable 实例的字段的信息。 vtable 还可能指示该字段不存在（因为此 FlatBuffer 是用旧版本的软件编写的，只是因为该信息对于此实例来说不是必需的，或者被视为已弃用），在这种情况下，将返回默认值。

表的内存开销（因为 vtable 很小且共享）和访问成本（额外的间接）开销较低，但提供了很大的灵活性。表甚至可能比等效结构消耗更少的内存，因为当字段等于默认值时不需要存储字段。

- Schema

虽然模式减少了一些通用性（您不能在没有模式的情况下读取任何数据），但它们有很多优点：

有关格式的大多数信息都可以纳入生成的代码中，从而减少存储数据所需的内存以及访问数据的时间。

数据定义的强类型意味着运行时更少的错误检查/处理（更少可能出错）。

模式使我们能够访问缓冲区而无需解析。


